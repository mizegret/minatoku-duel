name: Slash Commands
on:
  issue_comment:
    types: [created]
permissions:
  issues: write
  pull-requests: write
  contents: read
jobs:
  slash:
    if: ${{ startsWith(github.event.comment.body, '/') }}
    runs-on: ubuntu-latest
    steps:
      - name: Parse and execute
        uses: actions/github-script@v8
        with:
          script: |
            const body = context.payload.comment.body.trim();
            const [cmd, ...args] = body.split(/\s+/);
            const issue_number = context.payload.issue.number;
            const isPR = !!context.payload.issue.pull_request;
            const actor = context.payload.comment.user?.login || '';
            const role = context.payload.comment.author_association || 'NONE';
            async function comment(msg){ await github.rest.issues.createComment({ ...context.repo, issue_number, body: msg }); }
            async function addLabels(labels){ if(labels.length) await github.rest.issues.addLabels({ ...context.repo, issue_number, labels }).catch(()=>{}); }
            async function removeLabels(labels){ for (const name of labels){ await github.rest.issues.removeLabel({ ...context.repo, issue_number, name }).catch(()=>{}); } }
            function parseLabelList(list){ return list.split(',').map(s=>s.trim()).filter(Boolean); }

            // Restrict to OWNER/MEMBER except for /help
            const restricted = cmd !== '/help';
            const allowedRoles = ['OWNER','MEMBER'];
            const isAllowed = allowedRoles.includes(role);
            if (restricted && !isAllowed) {
              await comment(`@${actor} このコマンドはメンバー専用です（role=${role}）。/help で使い方を確認できます。`);
              return;
            }

            if (cmd === '/labels' && args[0] === 'add') {
              const labels = parseLabelList(args.slice(1).join(' '));
              await addLabels(labels);
              return;
            }
            if (cmd === '/labels' && args[0] === 'remove') {
              const labels = parseLabelList(args.slice(1).join(' '));
              await removeLabels(labels);
              return;
            }
            if (cmd === '/assign') {
              const users = args.map(a=>a.replace(/^@/, '')).filter(Boolean);
              if (users.length) await github.rest.issues.addAssignees({ ...context.repo, issue_number, assignees: users });
              return;
            }
            if (cmd === '/automerge' && isPR) {
              const on = (args[0]||'').toLowerCase()==='on';
              if (on) await github.rest.issues.addLabels({ ...context.repo, issue_number, labels: ['automerge']});
              else await github.rest.issues.removeLabel({ ...context.repo, issue_number, name: 'automerge' }).catch(()=>{});
              return;
            }
            if (cmd === '/rebase' && isPR) {
              try {
                await github.rest.pulls.updateBranch({ ...context.repo, pull_number: issue_number });
                await comment('Rebase requested: updating branch from base.');
              } catch (e) {
                await comment(`Rebase failed: ${e?.message || e}`);
              }
              return;
            }
            if (cmd === '/owner' && isPR) {
              const on = (args[0]||'').toLowerCase();
              if (on === 'on') await addLabels(['requires-owner']);
              if (on === 'off') await removeLabels(['requires-owner']);
              return;
            }
            if (cmd === '/allow' && isPR) {
              const what = (args[0]||'').toLowerCase();
              const onoff = (args[1]||'').toLowerCase();
              const map = { 'code-change': 'allow:code-change', 'large-pr': 'allow:large-pr' };
              const label = map[what];
              if (label) {
                if (onoff === 'on') await addLabels([label]);
                if (onoff === 'off') await removeLabels([label]);
              }
              return;
            }
            if (cmd === '/phase' && isPR) {
              const sub = (args[0]||'').toLowerCase();
              const onoff = (args[1]||'').toLowerCase();
              if (sub === 'switch') {
                if (onoff === 'on') await addLabels(['phase:switch']);
                if (onoff === 'off') await removeLabels(['phase:switch']);
              }
              return;
            }
            if (cmd === '/draft' && isPR) {
              const onoff = (args[0]||'').toLowerCase();
              const pull_number = issue_number;
              if (onoff === 'on') {
                await github.request('POST /repos/{owner}/{repo}/pulls/{pull_number}/convert-to-draft', { ...context.repo, pull_number }).catch(()=>{});
              } else if (onoff === 'off') {
                await github.request('POST /repos/{owner}/{repo}/pulls/{pull_number}/ready-for-review', { ...context.repo, pull_number }).catch(()=>{});
              }
              return;
            }
            if (cmd === '/link' && args[0]) {
              const parent = args[0].replace('#','');
              const issue = await github.rest.issues.get({ ...context.repo, issue_number });
              const body = (issue.data.body||'') + `\n\nParent: #${parent}`;
              await github.rest.issues.update({ ...context.repo, issue_number, body });
              return;
            }
            if (cmd === '/checklist') {
              const body = `以下の自己レビューを確認してください:\n\n- [ ] 1PR=1論点・小粒か\n- [ ] 日本語で概要・理由・受入条件を記載\n- [ ] Closes #<親Issue> を本文先頭に記載\n- [ ] lint/format/test/md/links/mermaid 済み\n- [ ] スクショや計測を添付（必要なら）\n- [ ] 機微情報なし\n`;
              await github.rest.issues.createComment({ ...context.repo, issue_number, body });
              return;
            }
            if (cmd === '/help') {
              await comment('Commands: /labels add|remove <a,b>, /assign <@u...>, /automerge on|off, /owner on|off, /allow <code-change|large-pr> on|off, /phase switch on|off, /draft on|off, /link <#id>, /checklist');
              return;
            }
            await comment('Unknown command. Try /help');
